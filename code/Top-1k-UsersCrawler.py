# 1000 Users information extraction
# Getting the profile information of those users

import pandas as pd
import numpy as np
import tweepy
import os
import CheckKeys  # use twitter_key
import matplotlib.pyplot as plt
import time
import csv


class TwitterAuthentication:

    # constructor
    def __init__(self):
        pass

    def twitter_authenticate(self):
        auth = tweepy.OAuthHandler(CheckKeys.twitter_key['consumer'], CheckKeys.twitter_key['consumerSecret'])
        auth.set_access_token(CheckKeys.twitter_key['access'], CheckKeys.twitter_key['accessSecret'])
        return auth


class TwitterDataExtraction:

    # constructor
    def __init__(self):
        self.twitter_authenticator = TwitterAuthentication()
        auth = self.twitter_authenticator.twitter_authenticate()
        self.api = tweepy.API(auth_handler=auth, wait_on_rate_limit=True,
                              wait_on_rate_limit_notify=True,
                              retry_errors=[401, 403, 404, 418, 500, 503],  # https://www.myintervals.com/api/errors.php
                              retry_count=5, retry_delay=5)

    def get_profile_info(self, name):

        # initialize variables
        name_twitter = None
        id_str = None
        screen_name = None
        location = None
        description = None
        verified = None
        followers_count = None
        friends_count = None
        statuses_count = None

        try:
            user_info = self.api.get_user(name)

            name_twitter = user_info.name
            id_str = user_info.id_str
            screen_name = user_info.screen_name
            location = user_info.location
            description = user_info.description
            verified = user_info.verified
            followers_count = user_info.followers_count
            friends_count = user_info.friends_count
            statuses_count = user_info.statuses_count

        except tweepy.TweepError as err:
            print('Error Generated by Tweepy')
            print(err.reason)

        completeData = [name, id_str, name_twitter, location, description, verified, followers_count,
                        friends_count, statuses_count]

        return completeData

    @classmethod
    def Plot(self, dataframe, xlabel, ylabel, title, filename):
        CommonPathImages = './MostFollowedTwitterProfiles/2021-03-09/Images'
        fig, ax = plt.subplots(figsize=(12, 10))

        plot = dataframe.value_counts().plot(kind='bar', color='blue', title=title)
        plot.set_xlabel(xlabel)
        plot.set_ylabel(ylabel)
        ax.set_ylim(0, max(dataframe.value_counts() + 2))
        figure = plot.get_figure()
        fileName = filename
        CompletePath = os.path.join(CommonPathImages, fileName)
        figure.savefig(CompletePath)

    @classmethod
    def SavingFilesCSV(self, df, filename):
        # check for folder if not the create one
        commonPath = './MostFollowedTwitterProfiles/2021-03-09'
        UniqueFolder = filename
        CompletePathForFiles = commonPath + '/' + UniqueFolder

        try:
            check_folder = os.path.isdir(CompletePathForFiles)
            if check_folder:
                print('Folder Path Exists')
            else:
                print('Create Folder Path')
                os.makedirs(CompletePathForFiles)
        except FileExistsError as err:
            print("Error while generating the folder", err)

        CompleteFile = filename + '.csv'
        CompleteFilePath = os.path.join(CompletePathForFiles, CompleteFile)
        df.to_csv(CompleteFilePath, encoding='utf-8')

    @classmethod
    def SavingCountCSV(self, df, filename):
        commonPath = './MostFollowedTwitterProfiles/2021-03-09'
        UniqueFolder = filename
        CompletePathForFiles = commonPath + '/' + UniqueFolder

        try:
            check_folder = os.path.isdir(CompletePathForFiles)
            if check_folder:
                print('Folder Path Exists')
            else:
                print('Create Folder Path')
                os.makedirs(CompletePathForFiles)
        except FileExistsError as err:
            print("Error while generating the folder", err)

        CompleteFile = filename + '_' + 'count' + '.csv'
        CompleteFilePath = os.path.join(CompletePathForFiles, CompleteFile)
        dfCount = df.value_counts()
        dfCount.to_csv(CompleteFilePath, encoding='utf-8')


if __name__ == '__main__':
    # upload the csv file
    CommonPath = './MostFollowedTwitterProfiles/2021-03-09/'
    FileName = 'MostFollowedTwitterProfiles_2021-03-09.csv'
    CompletePath = os.path.join(CommonPath, FileName)

    # uploading the dataset
    AllUsersDf = pd.read_csv(CompletePath, encoding='utf-8')
    print('Actual Dataset Shape {0}'.format(AllUsersDf.shape))
    # removing the suspended users identified till now
    # print(AllUsersDf['Comments'].unique())
    AllUsersDf_Active = AllUsersDf[AllUsersDf['Comments'] != 'Suspended']
    AllUsersDf_Active = AllUsersDf_Active[AllUsersDf_Active['Comments'] != 'A/C does not exists']
    AllUsersDf_Active.reset_index()
    print('Dataset w/o Suspended or Active {0}'.format(AllUsersDf_Active.shape))

    # extract the first 5000
    First_5000_Users = AllUsersDf_Active.iloc[:5000, :]
    # print(First_5000_Users)

    # out of 5000 extract first 1000
    First_1000_Users = First_5000_Users.iloc[:1000, :]
    # print(First_1000_Users)

    # extract the current values of the profile
    client = TwitterDataExtraction()
    UserNames = First_1000_Users['ScreenName']
    """
    # save in csv file
    fileName = 'Top1000TwitterUsers.csv'
    CompletePath2 = os.path.join(CommonPath, fileName)
    csv_file = open(CompletePath2, 'w')
    writer = csv.writer(csv_file, quoting=csv.QUOTE_MINIMAL)
    writer.writerow(['screen_name', 'id', 'name', 'location', 'description',
                     'verified', 'followers_count', 'friends_count', 'statuses_count'])

    counter = 0
    reset_counter = 0
    print('Start Data Extraction')
    for user in UserNames:
        counter += 1
        reset_counter += 1
        if reset_counter % 150 == 0:  # this did not reduce the wait time
            reset_counter = 0
            time.sleep(30)
        print(user)
        ProfileInfo = client.get_profile_info(name=user)
        writer.writerow([ProfileInfo[0], ProfileInfo[1], ProfileInfo[2], ProfileInfo[3], ProfileInfo[4],
                         ProfileInfo[5], ProfileInfo[6], ProfileInfo[7], ProfileInfo[8]])

    print('Complete total user {0}'.format(counter))

    """

    First_1000_Users = First_1000_Users.drop(['Index', 'Name', 'Comments', 'Unnamed: 20'], axis=1)
    column_names = First_1000_Users.columns
    # print(column_names)
    category = [column_names[2], column_names[4], column_names[7], column_names[9],
                column_names[11], column_names[13]]
    # print(category)

    Politics = First_1000_Users[['ScreenName', 'Profile URL', 'Politics(Country)']].loc[
        First_1000_Users['Politics'] == 'x']
    # print(Politics)

    Entertainment = \
        First_1000_Users[['ScreenName', 'Profile URL', 'Entertainment(Country)', 'Entertainment(Category)']].loc[
            First_1000_Users['Entertainment'] == 'x']
    # print(Entertainment)

    CorporateOrCompany = First_1000_Users[['ScreenName', 'Profile URL', 'Company (Country)']].loc[
        First_1000_Users['Corporate/Company'] == 'x']
    # print(CorporateOrCompany)

    Sports = First_1000_Users[['ScreenName', 'Profile URL', 'Sports(Type)']].loc[First_1000_Users['Sports'] == 'x']
    # print(Sports)

    NewsOrMedia = First_1000_Users[['ScreenName', 'Profile URL', 'News/Media(Language)']].loc[
        First_1000_Users['News/Media'] == 'x']
    # print(NewsOrMedia)

    Religion = First_1000_Users[['ScreenName', 'Profile URL', 'Religion(Type)']].loc[
        First_1000_Users['Religion'] == 'x']
    # print(Religion)

    # check if any rows are empty
    EmptyRows = First_1000_Users.loc[
        ('x' != First_1000_Users['Politics']) & (First_1000_Users['Entertainment'] != 'x') &
        (First_1000_Users['Corporate/Company'] != 'x') & (First_1000_Users['Sports'] != 'x') &
        (First_1000_Users['News/Media'] != 'x') & (First_1000_Users['Religion'] != 'x')]
    # print(EmptyRows.shape)

    # upload the actual profile information and add aamir information from the old file
    fileName = 'Top1000TwitterUsers.csv'
    CompletePath2 = os.path.join(CommonPath, fileName)
    Top1000UsersInfo = pd.read_csv(CompletePath2, encoding='utf-8', engine='python')
    # print(Top1000UsersInfo.head(n=2))
    # this file is used to extract Aamir Info
    top100_file = pd.read_csv('./top_twitter_follower.csv', encoding='utf-8', engine='python')

    # add aamir value
    aamir_khan_info = top100_file.loc[top100_file['screen_name'] == 'aamir_khan']
    aamir_khan_vals = aamir_khan_info.values  # this is numpy array
    # print(aamir_khan_vals)

    # get index value from the actual file
    aamir_index = Top1000UsersInfo.loc[Top1000UsersInfo['screen_name'] == aamir_khan_vals[0][2]].index.values[0]

    Top1000UsersInfo.iloc[aamir_index, 2] = aamir_khan_vals[0][1]
    Top1000UsersInfo.iloc[aamir_index, 3] = aamir_khan_vals[0][3]
    Top1000UsersInfo.iloc[aamir_index, 6] = aamir_khan_vals[0][5]
    Top1000UsersInfo.iloc[aamir_index, 7] = aamir_khan_vals[0][4]
    # print(Top1000UsersInfo.iloc[aamir_index, :])
    # sort the dataframe
    Top1000UsersInfo['followers_count'] = Top1000UsersInfo['followers_count'].astype(int)
    Top1000UsersInfoSorted = Top1000UsersInfo.sort_values(by='followers_count', ascending=False)

    # draw diagrams
    """
    client.Plot(dataframe=Politics['Politics(Country)'], xlabel="Country", ylabel="Frequency",
               title='Country Frequency - Politics', filename='PoliticsFrequency.png')

    client.Plot(dataframe=Entertainment['Entertainment(Country)'], xlabel="Country", ylabel="Frequency",
               title='Country Frequency - Entertainment', filename='EntertainmentCountryFrequency.png')

    client.Plot(dataframe=Entertainment['Entertainment(Category)'], xlabel="Category", ylabel="Frequency",
               title='Category Frequency - Entertainment', filename='EntertainmentCategoryFrequency.png')

    client.Plot(dataframe=CorporateOrCompany['Company (Country)'], xlabel="Country", ylabel="Frequency",
              title='Country Frequency - Company', filename='CorporateFrequency.png')

    client.Plot(dataframe=Sports['Sports(Type)'], xlabel="Sports(Type)", ylabel="Frequency",
                title='Sports Frequency - Type', filename='SportsFrequency.png')

    client.Plot(dataframe=NewsOrMedia['News/Media(Language)'], xlabel="SNews/Media(Language)", ylabel="Frequency",
                title='News/Media Frequency - Language', filename='NewsFrequency.png')

    client.Plot(dataframe=Religion['Religion(Type)'], xlabel="Religion(Type)", ylabel="Frequency",
                title='Religion Frequency - Type', filename='ReligionFrequency.png')
    

    # extract the countries
    countries_Politics = Politics['Politics(Country)']
    countries_Entertainment = Entertainment['Entertainment(Country)']
    countries_CorporateOrCompany = CorporateOrCompany['Company (Country)']

    all_countries = pd.concat([countries_Politics, countries_Entertainment, countries_CorporateOrCompany], ignore_index=True)
    #print(type(all_countries)) # series
    client.Plot(dataframe=all_countries, xlabel="Country", ylabel="Frequency",
                title='Country Frequency - Type', filename='CountryFrequency.png')

    """
    # group by plot Entertainment with Countries
    # row counts per group
    # Ref: https://stackoverflow.com/questions/19384532/get-statistics-for-each-group-such-as-count-mean-etc-using-pandas-groupby
    # Ref: https://stackoverflow.com/questions/40313727/bar-graph-from-dataframe-groupby

    Entertainment_grouped_country = Entertainment.groupby(['Entertainment(Category)', 'Entertainment(Country)']).size()

    # print(Entertainment_grouped_country)
    fig, ax = plt.subplots(figsize=(15, 10))
    CommonPathImages = './MostFollowedTwitterProfiles/2021-03-09/Images'

    """
    plot = Entertainment_grouped_country.plot(kind='bar', color="blue", fontsize=8) #color="indigo"
    ax.set_alpha(1.8)
    fig.autofmt_xdate(rotation=45)
    ax.set_title("Entertainment Grouping", fontsize=12)
    ax.set_xlabel("Country with Category", fontsize=10)
    ax.set_ylabel("Frequency", fontsize=8)
    fileName = 'EntertainmentGroup.png'
    CompletePath = os.path.join(CommonPathImages, fileName)
    figure = plot.get_figure()
    figure.savefig(CompletePath)
    """

    rows_Politics = Politics.shape[0]
    rows_Entertainment = Entertainment.shape[0]
    rows_CorporateOrCompany = CorporateOrCompany.shape[0]
    rows_Sports = Sports.shape[0]
    rows_NewsOrMedia = NewsOrMedia.shape[0]
    rows_Religion = Religion.shape[0]
    freq_cats = pd.DataFrame(data=[['Politics', rows_Politics], ['Entertainment', rows_Entertainment],
                                   ['CorporateOrCompany', rows_CorporateOrCompany], ['Sports', rows_Sports],
                                   ['NewsOrMedia', rows_NewsOrMedia], ['Religion', rows_Religion]],
                             columns=['Category', 'Frequency'])
    #print(freq_cats)

    """
    # this plot is done using matplot
    height = [rows_Politics, rows_Entertainment, rows_CorporateOrCompany, rows_Sports, rows_NewsOrMedia, rows_Religion]
    bars = ('Politics', 'Entertainment', 'CorporateOrCompany', 'Sports', 'NewsOrMedia', 'Religion')
    x_pos = np.arange(len(bars))
    plt.bar(x_pos, height, color='blue')
    plt.title('Category Frequency')
    plt.xlabel('Category')
    plt.ylabel('Frequency')
    plt.xticks(x_pos, bars)
    fileName = 'CategoryFrequency.png'
    CompletePath = os.path.join(CommonPathImages, fileName)
    plt.savefig(CompletePath)
    """

    """
    # save information in csv
    client.SavingFilesCSV(df=Politics, filename='Politics')
    client.SavingCountCSV(df=Politics['Politics(Country)'], filename='Politics')

    client.SavingFilesCSV(df=Entertainment, filename='Entertainment')
    client.SavingCountCSV(df=Entertainment['Entertainment(Country)'], filename='Entertainment_Country')
    client.SavingCountCSV(df=Entertainment['Entertainment(Category)'], filename='Entertainment_Category')

    client.SavingFilesCSV(df=CorporateOrCompany, filename='CorporateOrCompany')
    client.SavingCountCSV(df=CorporateOrCompany['Company (Country)'], filename='CorporateOrCompany')

    client.SavingFilesCSV(df=Sports, filename='Sports')
    client.SavingCountCSV(df=Sports['Sports(Type)'], filename='Sports')

    client.SavingFilesCSV(df=NewsOrMedia, filename='NewsOrMedia')
    client.SavingCountCSV(df=NewsOrMedia['News/Media(Language)'], filename='NewsOrMedia')

    client.SavingFilesCSV(df=Religion, filename='Religion')
    client.SavingCountCSV(df=Religion['Religion(Type)'], filename='Religion')
    """

    # update the csv file that will be used for the tracking purpose (undone)
    # add the additional information
    # Top1000UsersInfoSorted['Category'] = np.nan
    # Top1000UsersInfoSorted['Country'] = np.nan
    # Top1000UsersInfoSorted['Entertainment(Type)'] = np.nan
    # Top1000UsersInfoSorted['Sports(Type)'] = np.nan
    # Top1000UsersInfoSorted['News/Media(Language)'] = np.nan
    # Top1000UsersInfoSorted['Religion(Type)'] = np.nan

    # additional plotting (based on the feedback)
    EntertainmentPath = CommonPath + '/' + 'Entertainment'
    FileName = 'Entertainment_Category_count.csv'
    EntertainmentCatCountStatFile = os.path.join(EntertainmentPath, FileName)
    EntStatCat = pd.read_csv(EntertainmentCatCountStatFile, encoding='utf-8')
    # create updated count df for Entertainment
    Singer = EntStatCat.iloc[0, 1]
    Actor = EntStatCat.iloc[1, 1]
    MiscellaneousBig = EntStatCat.iloc[2:6, 1].sum()
    #print(EntStatCat)
    #print(MiscellaneousBig)

    freq_cats_new = pd.DataFrame(data=[['Politics', rows_Politics], ['Entertainment-Singer', Singer],
                                       ['Entertainment-Actor', Actor],
                                       ['Entertainment-MiscellaneousBig', MiscellaneousBig],
                                       ['CorporateOrCompany', rows_CorporateOrCompany], ['Sports', rows_Sports],
                                       ['NewsOrMedia', rows_NewsOrMedia], ['Religion', rows_Religion]],
                                 columns=['Category', 'Frequency'])
    #print(freq_cats_new)

    #client.SavingFilesCSV(df=freq_cats_new,filename='AllCatFreq')

    """
    # this plot is done using matplot (Entertainment Breakdown)
    height = [rows_Politics, Singer, Actor, MiscellaneousBig, rows_CorporateOrCompany, rows_Sports, rows_NewsOrMedia, rows_Religion]
    bars = ('Politics', 'Entertainment-Singer', 'Entertainment-Actor', 'Entertainment-MiscellaneousBig','CorporateOrCompany', 'Sports', 'NewsOrMedia', 'Religion')
    x_pos = np.arange(len(bars))
    fig.autofmt_xdate(rotation=45)
    plt.bar(x_pos, height, color='blue')
    plt.title('Category Frequency with Entertainment Breakdown')
    plt.xlabel('Category')
    plt.ylabel('Frequency')
    plt.xticks(x_pos, bars)
    fileName = 'CategoryFrequencywithEntBreakdown.png'
    CompletePath = os.path.join(CommonPathImages, fileName)
    plt.savefig(CompletePath)
    """
    """
    # Ref: https://www.python-graph-gallery.com/12-stacked-barplot-with-matplotlib
    # plot stack bar chart
    labels = ['Politics', 'Entertainment', 'CorporateOrCompany', 'Sports', 'NewsOrMedia', 'Religion']
    bar1 = [rows_Politics, Singer, rows_CorporateOrCompany, rows_Sports, rows_NewsOrMedia, rows_Religion]
    bar2 = [0, Actor, 0, 0, 0, 0]
    bar3 = [0, MiscellaneousBig, 0, 0, 0, 0]
    df_stacked = pd.DataFrame(data=[bar1, bar2, bar3], columns=labels)
    #print(df_stacked)

    # heights of bar1 + bar2
    bars = np.add(bar1, bar2).tolist()
    # positions of the bars
    r = [0, 1, 2, 3, 4, 5]
    barWidth = 1

    # Create brown bars
    plt.bar(r, bar1, color='brown', edgecolor='white', width=barWidth)
    # Create green bars (middle), on top of the first ones
    plt.bar(r, bar2, bottom=bar1, color='green', edgecolor='white', width=barWidth)
    # Create green bars (top)
    plt.bar(r, bar3, bottom=bars, color='red', edgecolor='white', width=barWidth)

    # Custom X-Y axis
    plt.title('Category Frequency with Entertainment Breakdown')
    plt.xticks(r, labels) #, fontweight='bold'
    plt.xlabel('Category')
    plt.ylabel('Frequency')
    fig.autofmt_xdate(rotation=45)

    fileName = 'CategoryFrequencywithEntBreakdown_2.png'
    CompletePath = os.path.join(CommonPathImages, fileName)
    plt.savefig(CompletePath)
    """





    """
    # save the screen name as txt
    UserNeedCrawling_txt = 'ListOfUserToCrawlSortedFollowers.txt'
    competePath3 = os.path.join(CommonPath,UserNeedCrawling_txt)
    txtFile = open(competePath3, 'w')
    for _, user in Top1000UsersInfoSorted.iterrows():
        #print(user['ScreenName'])
        txtFile.write(str(user['screen_name']))
        txtFile.write('\n')
    txtFile.close()
    """
"""
    # save as csv
    fileName2 = 'Top1000TwitterUsersFollowersSorted.csv'
    CompletePath3 = os.path.join(CommonPath, fileName2)
    Top1000UsersInfoSorted.to_csv(CompletePath3, encoding='utf-8')

"""
